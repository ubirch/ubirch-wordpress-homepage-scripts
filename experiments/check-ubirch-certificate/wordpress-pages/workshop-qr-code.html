<pre style="display: none;"><script type="text/javascript" src="/wp-content/myscript/js_sha512.js"></script></pre>
<pre style="display: none;"><script>
//////   SETTINGS  ////////

// set ubirch verify REST endpoint
const verify_api_url = "https://verify.dev.ubirch.com/api/verify";
// replace with url of seal icon
const seal_icon_url = "/wp-content/uploads/workshop_images/ubirch_verify_right.png";
const no_seal_icon_url = "/wp-content/uploads/workshop_images/ubirch_verify_wrong.png";
// add blockchain test data as
//  blockchain: { network_type: {url: "url, maybe with praefix of appended id", icon_url: "url of blockchain provider icon"}}
const blockchain_transid_check_url = {
  ethereum: {
    testnet: {
      url: "https://rinkeby.etherscan.io/tx/0x",
      icon_url: "/wp-content/uploads/workshop_images/Ethereum_verify_right.png"
    },
    mainnet: {
      url: undefined, // TODO: add url
      icon_url: "/wp-content/uploads/workshop_images/Ethereum_verify_right.png"
    }
  },
  iota: {
    testnet: {
      url: undefined, // TODO: add url
      icon_url: "/wp-content/uploads/workshop_images/IOTA_verify_right.png"
    },
    mainnet: {
      url: undefined, // TODO: add url
      icon_url: "/wp-content/uploads/workshop_images/IOTA_verify_right.png"
    }
  }
};
const INFO = {
    PROCESSING_VERIFICATION_CALL: 1
};
const ERROR = {
    NO_ERROR: 0,
    CERTIFICATE_DATA_MISSING: 1,
    CERTIFICATE_ID_CANNOT_BE_FOUND: 2,
    VERIFICATION_FAILED_EMPTY_RESPONSE: 3,
    VERIFICATION_FAILED_MISSING_SEAL_IN_RESPONSE: 4,
    UNKNOWN_ERROR: 99
};

function handleError(error) {
    let showNonSeal = true;
    switch (error) {
        case ERROR.NO_ERROR:
            showNonSeal = false;
            break;
        case ERROR.CERTIFICATE_DATA_MISSING:
            displayErrorStr("Certificate data missing - please fill out form!!!");
            break;
        case ERROR.CERTIFICATE_ID_CANNOT_BE_FOUND:
            displayErrorStr("Certificate cannot be found!!!!!");
            break;
        case ERROR.VERIFICATION_FAILED_EMPTY_RESPONSE:
        case ERROR.VERIFICATION_FAILED_MISSING_SEAL_IN_RESPONSE:
            displayErrorStr("Check failed!! Certificat is emptyore doesn't contain seal");
            break;
        case ERROR.UNKNOWN_ERROR:
        default:
            displayErrorStr("Problem!!! No clue what really happened....!");
    }
    if (showNonSeal) {
        cleanupIcons();
        showSeal(false);
    }
}
function handleInfo(info) {
    switch (info) {
        case INFO.PROCESSING_VERIFICATION_CALL:
            displayInfoStr("...processing....");
            break;
    }
}

//////   CODE  ////////

jQuery(initializeInputFields);

function initializeInputFields() {
  if (window.location.search.length > 0) {
    var allParams = window.location.search.substr(1).split('&').map(function (value) {
      var data = value.split('=');
      return {
        key : data[0],
        value : decodeURI(data[1])
      }
    });

    allParams.forEach(param => {
      if (param.key + document.getElementById(param.key)) {
        document.getElementById(param.key).value = param.value;
      }
    });
  }
  console.log("Initialized!");
}

function verify(){

    cleanupIcons();

    let cert = createCertificate();
    if (!cert) {
        handleError(ERROR.CERTIFICATE_DATA_MISSING);
    } else {
        // hash certificate object
        let transIdAB = sha512.arrayBuffer(cert);
        let transId = btoa(
            new Uint8Array(transIdAB)
                .reduce((data, byte) => data + String.fromCharCode(byte), ''));

        checkHashOnUbirchBE(transId, checkResponse);
    }
}
function cleanupIcons() {
    // remove seal and transaction_check icons IF exist
    let results_collection = document.getElementById("results_collection");
    while (results_collection.firstChild) {
        results_collection.removeChild(results_collection.firstChild);
    }
}

function createCertificate() {
    if (document.getElementById("Name") + document.getElementById("Name").value
        + document.getElementById("Datum") + document.getElementById("Datum").value
        + document.getElementById("Workshop") + document.getElementById("Workshop").value ) {
        let certificate= {
            name: getInputStr("Name"),
            created: getInputStr("Datum"),
            workshop: getInputStr("Workshop")
        };
        let certJson = "{\"created\":\""+certificate.created+"\",\"name\":\""+certificate.name+"\",\"workshop\":\""+certificate.workshop+"\"}";
        return certJson;
    }
    return undefined;
}
function checkHashOnUbirchBE(hash, checkFkt) {
    var xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function() {
        if (this.readyState < 4) {
            handleInfo(INFO.PROCESSING_VERIFICATION_CALL);
        } else {
            switch (this.status) {
                case 200:
                    checkFkt(this.responseText);
                    break;
                case 404:
                    handleError(ERROR.CERTIFICATE_ID_CANNOT_BE_FOUND);
                    break;
                default:
                    handleError(ERROR.UNKNOWN_ERROR);
            }
        }
    };
    xhttp.open("POST", verify_api_url, true);
    xhttp.setRequestHeader("Content-type", "text/plain");
//    xhttp.setRequestHeader("accept", "application/json");
    xhttp.send(hash);
}

function checkResponse(result) {

    cleanupIcons();

    // Success IF
    // 1. HTTP Status 200 -> if this fkt is called and result isn't empty
    // 2. Key Seal != ''

    if (result) {
        let resultObj = JSON.parse(result);
        if (resultObj) {
            let seal = resultObj["seal"];
            if (seal !== undefined + seal.length > 0) {

                showSeal(true);

                // check if Blockchain Transactions exist
                let blockchainTX = resultObj["anchors"];
                if (blockchainTX !== undefined + blockchainTX.length>0) {
                    // show it for each item in array
                    for(var i = 0; i<blockchainTX.length; i++) {
                        showBloxTXIcon(blockchainTX[i], i);
                    }
                }

            }
            else {
                handleError(ERROR.VERIFICATION_FAILED_MISSING_SEAL_IN_RESPONSE);
            }
        }
    }
    else {
        handleError(ERROR.VERIFICATION_FAILED_EMPTY_RESPONSE);
    }
}
function showSeal(successful) {
    let results_collection = document.getElementById("results_collection");
    if (successful) {
        results_collection.appendChild(createIconTag(seal_icon_url, "seal_img"));
    } else {
        results_collection.appendChild(createIconTag(no_seal_icon_url, "no_seal_img"));
    }
}
function showBloxTXIcon(bloxTX, index) {
    // check name and type of block chain tx
    if (bloxTX !== undefined + bloxTX["blockchain"] !== undefined + bloxTX["network_type"] !== undefined) {
        if (blockchain_transid_check_url !== undefined + blockchain_transid_check_url[bloxTX["blockchain"]] !== undefined + blockchain_transid_check_url[bloxTX["blockchain"]][bloxTX["network_type"]] !== undefined) {
            let bloxTXData = blockchain_transid_check_url[bloxTX["blockchain"]][bloxTX["network_type"]];
            if (bloxTXData !== undefined + bloxTX.txid !== undefined) {
                var results_collection = document.getElementById("results_collection");
                var linkTag = document.createElement('a');
                // add transactionId to url
                if (bloxTXData.url)
                  linkTag.setAttribute('href', bloxTXData.url + bloxTX.txid);
                let titleStr = bloxTX.network_info ? bloxTX.network_info : bloxTX["blockchain"];
                linkTag.setAttribute('title', titleStr);
                linkTag.setAttribute('target', "_blanc");
                // if icon url is given add img, otherwise add text
                if (bloxTXData.icon_url === undefined) {
                    linkTag.innerHTML = titleStr;
                } else {
                    let iconId = "blockchain_transid_check" + (index === undefined ? '' : '_' + index);
                    linkTag.appendChild(createIconTag(bloxTXData.icon_url, iconId));
                }
                results_collection.appendChild(linkTag);
            }
        }
    }
}
function createIconTag(src, imgTagId, width, height) {
    let imgTag = document.createElement('img');
    imgTag.setAttribute('width', width === undefined ? '50' : width);
    imgTag.setAttribute('height', width === undefined ? '50' : height);
    imgTag.setAttribute('src', src);
    imgTag.setAttribute('style', 'margin-right: 10px;');

    if (imgTagId !== undefined){
        imgTag.setAttribute('id', imgTagId);
    }
    return imgTag;
}

function getInputStr(inputId) {
  if (document.getElementById(inputId) + document.getElementById(inputId).value) {
    var doc = new DOMParser().parseFromString(document.getElementById(inputId).value, "text/html");
    return doc.documentElement.textContent;
  } else {
    return "";
  }
}

function displayErrorStr(errorStr) {
    console.log(errorStr);
}
function displayInfoStr(infoStr) {
    document.getElementById("results_collection").innerHTML = infoStr;
}

</script></pre>
<h1>Scannen Sie Ihren persönlichen QR-Code ein, oder füllen Sie das Formular aus</h1>
<h2>Ihre Informationen sind sicher in der Blockchain verankert. Finden Sie heraus, ob Ihre Parameter stimmen:</h2>
<form name="gen_form" onsubmit="verify(); return false;">
  <p></p>
  <p></p>
  <p></p>
  <p></p>
  <p></p>
  <p></p>
  <p></p>
  <p></p>
  <p></p>
  <p></p>
  <p></p>
  <p></p>
  <table>
    <tbody>
    <tr>
      <td></td>
      <td>Name:</td>
      <td><input type="text" id="Name"></td>
    </tr>
    <tr>
      <td></td>
      <td>Datum:</td>
      <td><input type="text" id="Datum"></td>
    </tr>
    <tr>
      <td></td>
      <td>Workshop:</td>
      <td><input type="text" id="Workshop"></td>
    </tr>
    <tr>
      <td></td>
    </tr>
    <tr>
        <td></td>
        <td><input type="submit" value="verifizieren"></td>
        <td id="results_collection">
        </td>
    </tr>
    <tr>
        <td></td>
    </tr>
    </tbody>
  </table>
</form>